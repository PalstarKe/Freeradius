######################################################################
server default {

	listen {
		type = auth
		ipaddr = *
		port = 0
		limit {
			max_connections = 16
			lifetime = 0
			idle_timeout = 30
		}
	}

	listen {
		ipaddr = *
		port = 0
		type = acct
		limit {
			# max_pps = 0
			# idle_timeout = 0
			# lifetime = 0
			# max_connections = 0
		}
	}

	listen {
		type = auth
		ipv6addr = ::
		port = 0
		limit {
			max_connections = 0
			lifetime = 0
			idle_timeout = 0
		}
	}

	listen {
		ipv6addr = ::
		port = 0
		type = acct

		limit {
			# max_pps = 0
			# idle_timeout = 0
			# lifetime = 0
			# max_connections = 0
		}
	}

	authorize {
		preprocess
		auth_log
		chap
		mschap
		digest
		suffix
		
		pap
		
		eap {
		        ok = return
		}
		
		sql
		
		# Get tenant ID for this customer
		update control {
		        Tmp-Tenant-ID := "%{sql:SELECT created_by FROM customers WHERE username = '%{User-Name}' LIMIT 1}"
		}
		

		# Get the tenant's plan + max_customers
		update control {
		        Tmp-Plan-ID := "%{sql:SELECT plan FROM users WHERE id = '%{control:Tmp-Tenant-ID}' LIMIT 1}"
		        Tmp-Max-Customers := "%{sql:SELECT max_customers FROM plans WHERE id = '%{control:Tmp-Plan-ID}'}"
		}
		
		# Count active sessions for this tenant in radacct
		if ("%{control:Tmp-Max-Customers}" != "-1") {
		        update control {
		            Tmp-Online := "%{sql:SELECT COUNT(*) FROM radacct WHERE created_by = '%{control:Tmp-Tenant-ID}' AND acctstoptime IS NULL}"
		        }
		
		        if ("%{control:Tmp-Online}" >= "%{control:Tmp-Max-Customers}") {
		            update control {
		                Tmp-Group-Name := "Disabled_plan"
		            }
		
		            update reply {
		                Reply-Message := "Your ISP plan has reached its customer limit."
		            }
		
		            accept
		        }
		}
		
		# Clear stale sessions if same MAC is already online
		if ("%{sql:UPDATE radacct set acctstoptime=ADDDATE(acctstarttime, INTERVAL acctsessiontime SECOND), acctterminatecause='Clear Stale Session' WHERE username='%{User-Name}' AND callingstationid='%{Calling-Station-Id}' AND acctstoptime is NULL}") {
		        update reply {
		            Reply-Message := "Disconnect Duplicate User & Clear Stale Session"
		        }
		        update disconnect {
		            User-Name = "%{request:User-Name}"
		            Calling-Station-Id = "%{Calling-Station-Id}"
		            Framed-IP-Address = "%{Framed-IP-Address}"
		        }
		}
		
		# If password check failed, assign Disabled_plan instead of reject
		if (!ok && &control:Auth-Type == 'PAP') {
			update control {
			    Auth-Type := Accept
			    Tmp-Group-Name := "Disabled_plan"
			}
		
			update reply {
			    Reply-Message := "Invalid credentials. Added to Disabled_plan"
			}
		
			accept
		}
		
	
		# MAC Lock check
		if ("%{sql:SELECT IF(maclock = 1, 1, 0) FROM customers WHERE username='%{User-Name}'}" == 1) {
		
			if ("%{sql:SELECT IF(mac_address IS NULL OR mac_address = '', 1, 0) FROM customers WHERE username='%{User-Name}'}" == 1) {
		            update control {
		                Tmp-String-0 := "%{sql:UPDATE customers SET mac_address='%{Calling-Station-Id}' WHERE username='%{User-Name}' AND (mac_address IS NULL OR mac_address = '')}"
		            }
		        }
		
		        if ("%{sql:SELECT IFNULL(FIND_IN_SET('%{Calling-Station-Id}', mac_address), 0) FROM customers WHERE username='%{User-Name}'}" <= 0) {
		            update reply {
		                Reply-Message := 'Wrong MAC Address'
		                Tmp-Group-Name := "Disabled_plan"
		            }
		            reject
		        }
		}
		
		logintime
		checkval
		expiration
		accessperiod
		Max-All-Session
	}

	authenticate {
		Auth-Type PAP {
			pap
		}
		Auth-Type CHAP {
			chap
		}

		Auth-Type MS-CHAP {
			mschap
		}
		mschap
		digest

		eap
	}


	preacct {
		preprocess
		acct_unique
		suffix
		files
	}

	accounting {
		unix
		sql
		exec
		attr_filter.accounting_response
		# CHECK OVER QUOTA USAGE
		update control {
			# Used QUOTA Value
			Tmp-Integer-0 := "%{sql:SELECT (SUM(acctinputoctets)+SUM(acctoutputoctets)) AS Total FROM radacct where acctstarttime >= CURDATE() AND radacct.username='%{User-Name}'}"
			# Value of FUP Bandwidth limit that is 512k, It is stored in a separate table
			Tmp-String-5 := "%{sql: SELECT value FROM fup WHERE attribute='Mikrotik-Rate-Limit' AND username='%{User-Name}'}"
			#Value of Actual QUOTA Allowed
			Tmp-String-1 := "%{sql:  SELECT value FROM radcheck WHERE attribute='Mikrotik-Total-Limit' AND username='%{User-Name}'}"
			Tmp-String-3 := "%{sql:select calledstationid from radacct where acctsessionid='%{Acct-Session-Id}'}"
		}

		if ("%{control:Tmp-Integer-0}" > "%{control:Tmp-String-1}"){
			# Update COA to Mikrotik
			update coa {
				User-Name = "%{User-Name}"
				Acct-Session-Id = "%{Acct-Session-Id}"
				NAS-IP-Address = "%{NAS-IP-Address}"
				Framed-IP-Address = "%{Framed-IP-Address}"
				Mikrotik-Rate-Limit = "%{control:Tmp-String-5}"
			}
		}
	}


	session {
		sql
	}

	post-auth {

		if (&control:Expired-Pool && &control:Expired-Pool != "") {
			# If Expired-Pool is set and is not empty, remove Framed-IP-Address and Framed-IP-Netmask
			update reply {
				Framed-IP-Address !* ANY
				Framed-IP-Netmask !* ANY
			}
		}

		# Check if Disabled-Pool exists and is not empty
		if (&control:Disabled-Pool && &control:Disabled-Pool != "") {
			# If Disabled-Pool is set and is not empty, remove Framed-IP-Address and Framed-IP-Netmask
			update reply {
				Framed-IP-Address !* ANY
				Framed-IP-Netmask !* ANY
			}
		}


		if (session-state:User-Name && reply:User-Name && request:User-Name && (reply:User-Name == request:User-Name)) {
			update reply {
				&User-Name !* ANY
			}
		}
		update {
			&reply: += &session-state:
		}

		reply_log
		sql
		exec

		#  Remove reply message if the response contains an EAP-Message
		remove_reply_message_if_eap

		Post-Auth-Type REJECT {
			update reply {
				Reply-Message = 'Wrong Password'
			}
			sql
			attr_filter.access_reject
			eap
			remove_reply_message_if_eap
		}
		Post-Auth-Type Challenge {
		}

		Post-Auth-Type Client-Lost {
		}

		if (EAP-Key-Name && &reply:EAP-Session-Id) {
			update reply {
				&EAP-Key-Name := &reply:EAP-Session-Id
			}
		}
	}

	pre-proxy {
	}

	post-proxy {

	}
}
